= Design

This section contains the design of the data path, the control unit, and other elements of the CPU.

The intention is to create a simple single-cycle design that conforms to the specification outlined above. References for the design include:

* "2018 Patterson and Hennessy - Computer organisation and design: the hardware software interface (RISC-V edition)", which provides an introduction to single-cycle RISC-V CPU design in chapter 4
* "2015 Li - Computer principles and design in verilog HDL", which provides a survey of practical techniques for programming general RISC CPUs in Verilog.

The design is intended for synthesis on Xilinx FPGAs. As a result, some design decisions are motivated by guidance in, e.g., https://docs.xilinx.com/r/en-US/ug949-vivado-design-methodology:"[Xilinx ultrafast design methodology].

== Design Summary

The two main components of this single-cycle design are the data path and the control path:

* The data path is responsible for the bulk of the calculations in each instruction cycle, and also stores the state of the processor (all the registers and memory). The data path is a sequential module, with all registers and memory updated on the rising clock edge. The data path will support all the RV32I and Zicsr instructions outlined in the specification, and has its behaviour controlled by a set of inputs from the control unit. It has the following interface:
** Inputs: clock, control lines from the control unit (including exception information)
** Outputs: fetched instruction, flags for when an instruction raises an exception
* The control unit is a purely combinational module which takes a fetched instruction and decodes it into control lines for the data path. In addition, it reads any exception flags raised by the data path and modifies the control lines to trap the exception if necessary. It has the following interface:
** Inputs: fetched instruction from the data path, exception flags from the data path
** Outputs: the control lines for the data path.

In the normal execution of an instruction which does not raise an exception and is not interrupted, the order of operations is as follows:

. The data path combinationally fetches an instruction (based on the program counter which is a register in the data path)
. The fetched instruction is an input to the control unit, which combinationally decodes the instruction and configures the data path control lines
. The computations involved in executing the instruction in the data path are all combinational, so the result of the computation stabilises at the write inputs to all the registers and memory
. On the next rising clock edge, the results of the instruction are loaded into registers and memory in the data path

In an instruction that raises an exception, the order of operations is as follows:

. The data path combinationally fetches an instruction (based on the program counter which is a register in the data path)
. The fetched instruction is an input to the control unit, which combinationally decodes the instruction and configures the data path control lines
. The computations involved in executing the instruction load to an exception flag being raised (an output from the data path)
. The control unit reads the exception flag, and sets control lines to raise an exception trap. In doing so, none of the control lines that caused the exception to be raised are modified (otherwise the exception flag would not persist; this requirement is due to having an all-combinational computation). However, all lines that involves writes to integer registers, data memory, or CSRs should be de-asserted so that the instruction raising the exception does not complete
. On the next rising clock edge, the CPU state is modified so as to raise the exception (program counter set to exception vector, CSRs modified, etc.)

Interrupts are always handled "first", before executing an instruction. An interrupt is handled as follows:

. The data path checks interrupt conditions in parallel with fetching the instruction, and sets an interrupt flag (output) if an interrupt is pending
. The control unit reads the interrupt flag, and sets control lines to raise an interrupt trap, instead of decoding the instruction.
. On the next rising clock edge, the CPU state is modified so as to raise the interrupt (program counter set to interrupt vector, CSRs modified, etc.)

== Data Path

=== Main ALU

The design will use a single ALU, which must support computational instructions, address calculations, and comparisons for branch operations. The structure of the RISC-V instructions means that it is possible to consistently route operands to the same input ports of the ALU. The computations required by the RV32I instructions are given below:

* `rs1_data OP rs2_data`, for register-register and conditional branch instructions
* `rs1_data OP imm`, for register-immediate, load/store, and `jalr` instructions
* `pc + imm`, for `jal` and `auipc`
* `0 + imm`, for `lui` (could also bypass the ALU)

NOTE: The `jalr` instruction also requires masking the ALU result using `0xffff_fffe` before writing to `rd`. This is dealt with outside the ALU module.

The main ALU module will take the 32-bit immediate `imm` from an external immediate generation module, which is assumed to supply the correct immediate for the instruction type.

For Zicsr instructions, the following operands are required:

* `rs1_data OR csr_rdata` for `csrrs`
* `imm OR csr_rdata` for `csrrsi`
* `!rs1_data AND csr_rdata` for `csrrc`
* `{ 27{1'b1}, !imm[4:0] } AND csr_rdata` for `csrrci`

NOTE: The bitwise negation of the `imm` instruction only applies to the bottom 5 bits (`uimm` in CSR instructions); otherwise, `csrrci` could inadvertently clear high bits of the CSR (above bit 4).

In the formulas above, the order of operands represents how they will be mapped to the input ports of the ALU. The following pointers motivate the choice of operand order:

* The `rs1_data` field is routed to port 1 of the ALU, and immediates are typically routed to port 2. This implies the ALU shift operation must use the first port for the value to be shifted, and use the second port for the shift amount.
* For Zicsr instructions, the order of operands was chosen to fix the position of `csr_rdata`, and keep `rs1_data` on port 1, at the expense of having an immediate on port 1 (inconsistent with RV32I).

The ALU module is described below.

==== ALU Module

The ALU should be able to perform the following operations on its operands `a` and `b`, to produce result `r`:

* addition: `r = a + b`
* subtraction: `r = a - b`
* and: `r = a & b`
* or: `r = a | b`
* xor: `r = a ^ b`
* shift left: `r = a << b`
* shift right (logical): `r = a >> b`
* shift right (arithmetic): `r = a >>> b`
* set if less than (unsigned): `r = a < b (unsigned)? 1 : 0`
* set if less than (signed): `r = a < b (signed)? 1 : 0`

The only required flag is `zero`, for use by `beq` and `bne` instructions. Other conditional branch instructions can use `r[0]` with the operation set-if-less-than (signed/unsigned). 

The signature for the `alu` module is shown below:

[,verilog]
----
/// Arithmetic Control Unit
///
/// This is a purely combinational ALU implementation.
///
/// The operation depends on the 4-bit alu_op as
/// follows: 
///
/// 0_000: r = a + b
/// 1_000: r = a - b
/// 0_001: r = a << b
/// x_010: r = a < b ? 1 : 0
/// x_011: r = signed(a) < signed(b) ? 1 : 0
/// x_100: r = a ^ b
/// 0_101: r = a >> b
/// 1_101: r = signed(a) >>> signed(b)
/// x_110: r = a | b
/// x_111: r = a & b
///
/// The separation in alu_op indicates that the top bit
/// comes form bit 30 of the instruction, and the bottom
/// 3 bits come from funct3, in R-type register-register
/// instructions.
///
/// For I-type register-immediate instructions, ensure
/// that the top bit is 0 for addi, slti, sltiu, xori
/// ori, and andi. For slli, srli, and srai, set the top
/// bit to bit 30 of the instruction, and set b to the
/// shift amount (shamt) field. Set the low three
/// bits to funct3 in all cases.
///
module alu(
    input [31:0] a, // First 32-bit operand
    input [31:0] b, // Second 32-bit operand
    input [3:0] alu_op, // ALU control signals (see comments above)
    output [31:0] r, // 32-bit result
    output zero // 1 if r is zero, 0 otherwise
    );
----

==== Main ALU Wrapper

A wrapper module is used to encapsulate the main ALU, and ensure inputs are mapped to the correct ports of the ALU consistently with the operation being implemented. The signature of the module is:

[,verilog]
----
/// Main ALU Wrapper Module
///
/// This module routes input operands to the
/// main ALU depending on the instruction
/// being executed.
///
/// The arguments for the ALU are selected
/// by arg_sel as follows:
///
/// 000: rs1_data OP rs2_data
/// for register-register and conditional branch instructions
///
/// 001: rs1_data OP imm
/// for register-immediate, load/store, and jalr instructions
///
/// 010: pc + imm
/// for jal and auipc
///
/// 011: rs1_data OR csr_rdata
/// for csrrs
/// 
/// 100: imm OR csr_rdata
/// for csrrsi
///
/// 101: !rs1_data AND csr_rdata
/// for csrrc
/// 
/// 110: { 27{1'b1}, !imm[4:0] } AND csr_rdata
/// for csrrci
/// 
/// Whenever OP is used above, alu_op is used to
/// select the ALU operation following the comments
/// in the alu module.
///
/// Ensure that the imm input is consistent with the
/// operation being implemented (depending on the
/// instruction format).
///
/// In this design, the lui instruction bypasses the ALU.
module main_alu_wrapper(
       input [2:0] arg_sel, // Select the ALU arguments
       input [3:0] alu_op, // Select the ALU operation (when required)
       input [31:0] rs1_data, // Value of rs1 register
       input [31:0] rs2_data, // Value of rs2 register
       input [31:0] imm, // 32-bit immediate
       input [31:0] pc, // Current program counter
       input [31:0] csr_rdata, // Read-data for CSR bus
       output [31:0] main_alu_result, // ALU output
       output main_alu_zero // ALU zero flag output
       );
----

=== Immediate Generation

All immediates encoded in RISC-V instructions should be extended to 32-bit (mostly sign-extended, but zero-extended for Zicsr instructions. In addition, each instruction in RV32I or Zicsr only uses one immediate per instruction (either `imm` or `uimm`), meaning one module can decode this single immediate and expose it as one output `imm`. The module signature is as follows:

[,verilog]
----
/// Extract an immediate encoded in the instruction
///
/// Each RV32I or Zicsr instruction contains at most
/// one immediate, which is extracted and converted to
/// a 32-bit format by this module. For Zicsr instructions,
/// the uimm field is also zero-extended to 32 bits, and
/// output using the same imm output.
///
/// The reference for how immediates are decoded is
/// v1_f2.4. The sel input picks the output as follows:
///
/// 000: { 21{instr[31]}, instr[30:20] }, I-type
/// 001: { 21{instr[31]}, {instr[30:25]}, instr[11:7] }, S-type
/// 010: { 20{instr[31]}, instr[7], instr[30:25], instr[11:8], 1'b0 }, B-type
/// 011: { instr[31:12], 12{1'b0} }, U-type
/// 100: { 12{instr[31]}, instr[19:12], instr[20], instr[30:21], 1'b0 }, J-type
///
/// 101: { 27{1'b0}, instr[24:20] }, Zicsr
///
module imm_gen(
       input [2:0] sel, // Set immediate to extract
       input [31:0] instr, // Current instruction
       output [31:0] imm // Output 32-bit immediate
       );
----

=== Register File

The register file is combinational with respect to reads (`rs1` determines `rs1_data`, and `rs2` determines `rs2_data`), and sequential for writes (`rd_data` is written to `rd` on the rising clock edge if `write_en` is set). The signature for the data path is as follows:

[,verilog]
----
/// 32-bit Register file
///
/// There are 32 32-bit registers x0-x31, with x0 hardwired
/// to zero. This module provides two combinational output
/// ports, controlled by the two addresses rs1 and src, and
/// a single registered write (on the rising edge of the clock
/// when the write enable signal is asserted).
///
/// There is no reset; on power-on, the register values are 
/// set to zero.
///
module register_file(
    input clk, // clock
    input write_en, // write enable for rd
	input [31:0] rd_data, // data for write
    input [4:0] rs1, // source register index
    input [4:0] rs2, // source register index
    input [4:0] rd, // destination register index for write
    output [31:0] rs1_data, // read port for rs1
    output [31:0] rs2_data // read port for rs2
    );
----

The fields `rs1`, `rs2`, and `rd` are routed from fixed locations in `instr`. The source for `rd_data` is selected from one of the following options:

* `main_alu_result` for register-register, register-immediate, and `auipc` instructions
* `data_mem_rdata` for load instructions
* `csr_rdata` for Zicsr instructions
* `pc_plus_4` for unconditional jump instructions
* `imm` for `lui`

To simplify the data path, the register file is wrapped in a module that routes the register indices from the instruction, and selects the source for writing data:

[,verilog]
----
/// Write data for rd in register file
///
/// The rd_data_sel arguments selects between the inputs:
///
/// 000: main_alu_result,
/// for register-register, register-immediate, and auipc instructions
///
/// 001: data_mem_rdata
/// for load instructions
///
/// 010: csr_rdata
/// for Zicsr instruction
///
/// 011: pc_plus_4
/// for unconditional jump instructions
///
/// 100: { instr[31:12], 12{1'b0} } (from instr input)
/// for lui instruction
///
module register_file_wrapper(
	input clk, // for writing
	input write_en, // 1 to write data to rd; 0 otherwise
	input [1:0] rd_data_sel, // pick what to write to rd
	input [31:0] main_alu_result, // the output from the main ALU
	input [31:0] data_mem_rdata, // data output from data memory bus
	input [31:0] csr_rdata, // data output from CSR bus
	input [31:0] pc_plus_4, // current pc + 4, from pc module
	input [31:0] instr, // current instruction
    	output [31:0] rs1_data, // read port for rs1
    	output [31:0] rs2_data // read port for rs2
    );
----

=== Data Memory Bus

The design will use a simple bus for accesses to data memory (the target for loads and stores). Using a bus allows separate devices (e.g. main memory, and I/O devices) to be separated into different modules.

Instead of using an enable signal to pick which device is active on the bus, each device will determine whether it should handle the read or write, by setting a "claim" signal. The read outputs from all the devices are ORed together, and devices not claiming the signal set their output to zero.

The claim signals from all the devices are ORed together. On a read or write, this signal can be used to check that at least one device will handle the request. If no device will handle the request, a load/store access fault can be raised.

The (logical) bus interface is as follows:

[,verilog]
----
interface data_mem_bus();
   bit        clk; // writes are performed on the rising clock edge
   bit [31:0] addr; // the read/write address
   bit [1:0]  width; // the width of the read/write (byte, halfword, word)
   bit [31:0] rdata; // read-data returned from device
   bit [31:0] wdata; // write-data passed to device
   bit	      write_en; // whether to perform a write (or just a read)
   bit	      claim; // devices will claim read/write based on address/width
endinterface
----

The OR logic for `claim` and `rdata` will be handled using modports, one per device (and one for the host).

The devices on the bus are:

* The main memory module (RAM)
* Any memory-mapped CSRs (in particular, the timer interrupt controller)
* Any memory-mapped peripherals

The data memory bus is only used for loads and stores (instruction fetch does not use this bus in this design).

For both load and store instructions, the address is calculated by the ALU, so the `addr` line is hardwired to the main ALU output. The `width` field depends on the instruction, and is driven by the control unit. The `write_en` line is set only for store instructions. The `wdata` field is hardwired to `rs2_data`, which is the only source for writes to data memory.

The `claim` output is used by the control unit to potentially raise load/store access faults. The `rdata` output is hardwired to the register file wrapper, which is the only user of data memory bus data (load instructions).

=== CSR Bus

The CSR bus is similar to the data memory bus:

[,verilog]
----
interface csr_bus();
   bit        clk; // writes are performed on the rising clock edge
   bit [11:0] addr; // the read/write address
   bit [31:0] rdata; // read-data returned from a CSR device
   bit [31:0] wdata; // data to be written to a CSR device
   bit	      write_en; // whether to perform a write (or just a read)
   bit	      claim; // devices will claim read/write based on address
endinterface
----

Exactly one CSR device attached to the bus will be responsible for asserting the claim signal, and either writing data or returning data. The other devices return zero on the `rdata` line. All the `rdata` lines for each device are ORed together to generate the bus `rdata` signal (and the same for the bus `claim` signal).

Only Zicsr instructions interact with the CSR bus. The `addr` input always comes from a fixed position in the instruction, and is hardwired there. The `write_en` input is set by the control unit. The data written back to the CSR comes from either `rs1_data`, the main ALU output, or the `uimm` field of the instruction (via the immediate generation module). The module selecting the resulting value for `wdata` is:

[,verilog]
----
/// CSR write data source selection
///
/// Depending on the value of sel, the CSR write data
/// source is chosen as follows:
/// 
/// 00: rs1_data, for csrrw
/// 01: main_alu_result, for csrrs, csrrc, csrrsi, csrrci
/// 10: { imm }, for csrrwi
///
module csr_wdata_sel(
       input sel,
       input [31:0] rs1_data, // from the register file
       input [31:0] main_alu_result, // from the main ALU
       input [31:0] imm, // uimm, from immediate generator
       output [31:0] csr_wdata // to the CSR bus
       );
----

The output `rdata` from the CSR bus is routed to the register file wrapper (`csr_rdata`), for writing to `rd`, and is also routed to main ALU wrapper for use in computations that write back to the CSR. The `csr_claim` signal is returned to the control unit, to check for illegal instruction (on missing CSR).


////
== OLD VERSION BELOW

== Data path (instructions)

This section describes how the instruction uses the hardware of the data path.

=== Register-register instructions

The following instructions operate on two register operands and write their result into the register file: `add`, `sub`, `sll`, `slt`, `sltu`, `xor`, `srl`, `sra`, `or`, `and`. Supporting these instructions requires:

* a register file that supports two port reads (combinationally depending on the `rs1` and `rs2` fields in the R-type instruction format); and supports a single-port registered write port, with the write register index selected from the `rd` field in the R-type instruction.
* an ALU with two input ports for 32-bit operands; that supports the arithmetic and logical operations above; has inputs routable from the register file read data output ports; and has an output routable to the register file write data input port.
* the next `pc` is `pc+4`.

=== Register-immediate instructions

The following instructions operate on a register operand and an immediate encoded in the instructions: `addi`, `slti`, `sltiu`, `xori`, `ori`, `andi`, `slli`, `srli`, `srai`. Supporting these instructions requires:

* a way to route the `imm[11:0]` field of the I-type instruction to the second input operand of the ALU (the first input operand comes from the `rs1` output of the register file)
* in the case of `slli`, `srli`, and `srai`, the `imm[11:0]` fields must be masked to the lower 5 bits, and bit 30 of the instruction should be used to control the type of right shift operation in the ALU (1 for arithmetic shift, 0 for logical).
* routing the output of the ALU to the write port of the register file, with register index from the `rd` field of the I-type instruction.
* the next `pc` is `pc+4`.

=== Branch instructions

The following instructions operate on two register operands, and take a pc-relative branch if a condition is satisfied: `beq`, `bne`, `blt`, `bge`, `bltu`, `bgeu`. Supporting these instructions requires:

* routing the two register operands to the ALU, the same as the register-register instructions
* setting the operation of the ALU depending on the instruction:
** `beq`: subtract
** `bne`: subtract
** `blt`: use `slt`
** `bge`: use `slt`
** `bltu`: use `sltu`
** `bgeu`: use `sltu`
* creating a `branch_taken` signal from the output of the ALU depending on the instruction:
** `beq`: `zero`
** `bne`: `!zero`
** `blt`: `alu_result[0]`
** `bge`: `!alu_result[0]`
** `bltu`: `alu_result[0]`
** `bgeu`: `!alu_result[0]`
* form the immediate `offset` from the `imm` fields in the B-type instruction.
* if `branch_taken` signal is set and `pc + offset` is not four-byte aligned, raise `InstructionAddressMisaligned` exception; otherwise, next `pc` is `pc + offset`.
* if `!branch_taken`, next `pc` is `pc + 4`.

Note: does this instruction require two ALUs? One for the branch condition comparison and one for `pc + offset`? Or can we maybe use the same ALU being used for `pc + 4` to compute `pc + offset`?

=== Load instructions

The following instructions read a value from memory and write it to a destination registers: `lb`, `lh`, `lw`, `lbu`, `lhu`. Supporting these instructions requires:

* routing the `base` (`rs1`) register index from the I-type instruction to the register file
* routing the output of the register file to the first input of the ALU
* routing the `offset` stored in the instruction to the other input of the ALU
* setting the ALU operation to addition
* routing the output of the ALU to the physical memory attributes checker
* if the memory read will be invalid, raise `LoadAccessFault` exception and prevent memory read/register write.
* if read is OK, configure the memory to read a byte, halfword, or word, based on the instruction
* routing the output from the data memory through a zero-extension or sign-extension based on the instruction
* routing that result to the register file write port (write register comes from `rd` value in instruction).
* set next `pc` to `pc + 4`.

=== Store instructions

The following instructions write a value from a register to a memory address: `sb`, `sh`, `sw`. Supporting these instructions requires:

* routing the `base` (`rs1`) register index from the S-type instruction to the first read port of the register file
* routing the first output of the register file to the first input of the ALU
* obtaining the `offset` from the `imm` fields of the S-type instruction and placing the result on the second ALU 
* setting the ALU operation to addition
* routing the `src` register index from the S-type instruction to the second read port of the register file
* routing the second output port of the register file to the write input of the data memory.
* routing the output of the ALU to the physical memory attributes checker
* if the memory read will be invalid, raise `StoreAccessFault` exception and prevent memory write.
* if write is OK, configure memory to write a byte, halfword, or word, based on the instruction
* set next `pc` to `pc + 4`

=== Upper immediate instructions

These instruction construct upper immediates: `lui` and `auipc`; they are implemented by:

* routing the `dest` field of the U-type instruction to the write port address of the register file.
* combine the `imm` field of the U-type instruction with 12 low zeros; route it to port 2 of the ALU
* set the ALU operation to addition
* if the instruction is `auipc`, route the current `pc` to port 1 of the ALU; else 0 for `lui`.
* route the output of the ALU to the write data port of the register file
* set next `pc` to `pc + 4`

=== Jump and link

The `jal` instruction is implemented by:

* routing the `imm` fields of the J-type instruction through a sign-extending module
* routing the sign extended result to the second port of the ALU
* routing the current `pc` to the first port of the ALU
* setting the ALU operation to addition
* checking the result from the ALU is four-byte aligned. If not, raise `InstructionAddressMisaligned` exception and do not perform the register writes below.
* setting the next `pc` to the output from the ALU.
* route the `dest` field of the J-type instruction to the write address port of the register file
* setting the write data port of the register file to `pc + 4`

=== Jump and link register

The `jalr` instruction is implemented by:

* routing the `imm` fields of the I-type instruction to a sign extension module
* routing the result of the sign extension to the second port of the ALU
* routing the `base` field of the I-type instruction to the first read port of the register file
* routing the first output port of the register file to the first port of the ALU
* setting the ALU operation to addition
* routing the output of the ALU through a mask to set the low bit to zero
* checking the result is four-byte aligned. If not, raise `InstructionAddressMisaligned` exception and do not perform the register writes below.
* routing the result to the next `pc`.
* route the `dest` field of the J-type instruction to the write address port of the register file
* setting the write data port of the register file to `pc + 4`

=== Control and status register instructions

The instructions `csrrw`, `csrrs`, `csrrc`, `csrrwi`, `csrrsi`, and `csrrci` read and write CSRs. The `*rw*` instructions always write irrespective of arguments, and the `*rs*/*rc*` instructions always read irrespective of arguments. These instructions are implemented by:

* routing the CSR address to the CSR address bus (which specifies a CSR to both read and write)
* if the CSR does not exist, raise an illegal instruction exception and do not perform the operations below.
* routing the destination register index `rd` of the instruction to the write data address port of the register file.
* routing the data output of the CSR to the write data input port of the register file.
* routing the data output of the CSR to the first port of the ALU
* configure the ALU operation to be OR (`csrrs(i)`) or AND (`csrrc(i)`) depending on the instruction
* route the `rs1` field to the first read port of the register file (this can be done even for immediate instructions; the output of the register file is unused)
* select the second port of the ALU from: 
** the output of the first read port on the register file (`csrrs`)
** the negated output of the first read port on the register file (`csrrc`)
** the `uimm` instruction field (zero-extended) (`csrrsi`)
** the `!uimm` field (zero-extended) (`csrrci`)
* select the CSR write data line from
** the first read output from the register file (`csrrw`)
** the `uimm` field from the instruction (`csrrwi`)
** the output of the ALU (the rest of the instructions)
* set the CSR bus write enable signal depending on the instruction and whether `rs1` is zero, or `uimm` is zero.
* if the attempted write to the CSR is read-only, raise an illegal instruction exception, and prevent the CSR data being written to `rd`.

In the CSR bus, if a write is performed, ensure this prevents any automatic updating action the CSR may take when it is not written. Each CSR module on the CSR bus is responsible for only updating its writable fields (and masking out attempted changes to non-writable fields, or WARL fields where the written value is not legal).

=== Nops

The instructions `fence` and `wfi` are implemented as `nop`:

* set the next `pc` to `pc + 4`

=== Environment calls

The instructions `ecall` and `ebreak` raise the exceptions `MmodeEcall` and `Breakpoint` respectively, and take no further action.

=== Return from trap

The `mret` instruction is implemented by:

* restoring the `MPIE` bit to the `MIE` bit in the `mstatus` CSR
* setting the `MPIE` bit to 1 in the `mstatus` CSR
* setting the next `pc` to `mepc`

== Data path (modules)

This presents a draft of the different components of the data path, focusing on what they will do while different instructions are executing. 

=== Raising an exception

The exception mechanism is partly implemented in the data path and partly in the control unit. The policy for raising an exception in this single-cycle design is that no combinational calculation which caused the exception to be raised can be modified by the exception (otherwise there would be a circular dependency in the calculation). As a result, extra logic may need to be implemented that disables any actions that would be taken where there is no exception, in cases where disabling an action would also de-assert the exception itself.

Due to the results of calculations performed in the combinational work of an instruction, the data path may need to raise an exception. When this happens, the instruction should be prevented from registering the results of the instruction that would occur if no exception occurred, by having the control unit disable these writes. In addition, the following actions take place when an exception is raised:

* the `mepc` CSR is set to `pc`
* the `mcause` register is set to be written with the exception cause
* the `MIE` bit is saved to `MPIE` in the `mstatus` CSR, and the `MIE` bit itself is cleared.
* the next `pc` is set to the exception `BASE` address stored in `mtvec` (this can be hardwired in this design)

Note that many of these steps also happen for an `interrupt` (they are generic trap steps). However, an interrupt sets a different `mepc` value and `mcause`, and jumps to a vectored interrupt).

=== `pc` (sequential)

The current `pc` is a single 32-bit register, which is loaded on the rising edge of the clock. The next program counter is either calculated directly, or is the output from an ALU, configured as an adder, whose input `B` is controlled by a multiplexer. The configuration of the calculation is as follows:

* `A = pc`, `B = 4`: most instructions
* `A = pc`, `B = offset`: control flow instructions; `offset` is
** obtained from sign extending `imm` fields in instruction (branch instructions)
** output from `main_alu` for `jal`
* `A = exception_vector`, `B = interrupt_offset`: for exceptions and interrupts
* `next_pc = 0xffff_fffe & jalr_target`: for `jalr` instructions, `jalr_target` is the output from `main_alu`. It needs the bottom bit masking out.
* `next_pc = mepc`: `mret` instruction only

The output from this adder is checked for instruction alignment (multiple of 4). If the `pc` is not four-byte aligned, an `InstructionAddressMisaligned` exception is raised.

The module that manages the program counter has the following signature:

[,verilog]
----
/// Program counter
///
/// The program counter is updated on the rising edge
/// of the clock, and is the main sequential element
/// that controls the rest of the combinational
/// computations in the data path.
///
/// On the rising edge of the clock, pc is set to next_pc.
/// The calculation of next_pc is described below.
///
/// The control signal sel sets the calculation of
/// maybe_next_pc as follows:
///
/// 00: pc + 4
/// 01: mepc
/// 10: 32'hffff_fffe & main_alu_r
/// 11: pc + offset
///
/// The control line trap decides whether maybe_next_pc
/// becomes the next_pc or not:
///
///                       trap
///                        |
/// maybe_next_pc -------- 
///                       MUX ----- next_pc
/// trap_pc --------------
///
/// where trap_pc = exception_vector + interrupt_offset
/// 
/// If the maybe_next_pc is not a multiple of 4 when adding
/// offset or using jalr_target (i.e. pc_src 01 or
/// 10), then InstructionAddressMisaligned exception
/// is raised (indicated by instr_addr_mis set). This should
/// cause an external control system to set trap. It is
/// important that the instr_addr_mis signal continues to
/// be asserted even after trap is set, which is why
/// maybe_next_pc is separate from next_pc (this allows 
/// a fully combinational single-cycle design).
///
module pc(
        input clk, // the clock (pc updates on rising edge)	
	input [1:0] sel, // select the next pc for normal program flow
	input [31:0] mepc, // the pc to use for mret
	input [31:0] exception_vector, // from mtvec
	input [31:0] interrupt_offset, // 0 for exception; for interrupt, specify byte offset to trap vector
	input [31:0] offset, // offset to add to the current pc
	input [31:0] main_alu_r, // un-masked jalr target PC
	input trap, // 0 for normal program flow, 1 for trap
	output [31:0] pc, // the current program counter
	output [31:0] pc_plus_4, // the current program counter + 4
	output instr_addr_mis, // flag for instruction address misaligned exception
	);
----

=== Instruction fetch at `pc` (combinational)

The instruction memory is an instance of a `instr_mem` module, which has the following signature:

[,verilog]
----
/// Fetch an instruction from program memory
///
/// The instruction memory is preloaded with instructions at
/// synthesis time in this design. It is combinational, so the
/// output changes directly with the input pc. No checking is
/// performed for pc 4-byte alignment (the lower 2 bits of pc
/// are just ignored).
///
/// An InstructionAccessFault exception is raised if the pc is 
/// out of range for the valid program memory addresses. In 
/// this design, the program memory is 1024 bytes, so that
/// occurs if pc > 1020. If the exception is raised, the instr
/// output has an unspecified value.
///
module instr_mem(
	input [31:0] pc, // current pc
	output [31:0] instr, // the instruction at pc
	output instr_access_fault // flag for instruction access fault exception
	);
----

=== Data memory read/write (sequential)

The data memory is a byte-addressable which holds both main memory and memory-mapped I/O regions. It is sequential because write data is stored into the memory on the rising edge of the clock (read data is combinational). There is one write port and one read port. The only instructions which interact with the data memory are load and store instructions.

The signature of the `data_mem` module is as follows:

[,verilog]
----
/// Data memory module with one write and one read port
///
/// To read, set the read_addr and read data from the
/// read_data output (valid if no load exception occurred).
///
/// To write, set the write_addr and write_data, and set
/// the write_en. Data will be written on the rising clock
/// edge.
///
/// For both reads and writes, the width is specified using
/// the write_width or read_width input, which has the following
/// encoding (binary):
///
///  00: read/write a byte (8 bits)
///  01: read/write a half word (16 bits)
///  10: read/write a word (32 bits)
///
/// On a non-word read, the high bits of the output contain
/// zeros. On a non-word write, the high bits of the input are
/// ignored.
///
/// Both reads and writes of main memory and I/O memory
/// can use any alignment and width, so {load,store} address
/// misaligned exceptions do not occur in this design.
///
/// Access fault exceptions occur based on the read or write
/// address. On a load access fault, the read_data is unspecified.
/// On a store access fault, no data is written, even if write_en
/// is set. The flags for access faults are both combinational;
/// they are set immediately based on the address (a store access
/// fault does not wait until the rising clock edge).
///
/// The memory map for this data memory is as follows (hexadecimal
/// ranges a - b mean the region starts at a, and the first byte outside
/// the region is b):
///
/// I/O region: 
///    1000_0000 - 1000_0004 (msip)
///    1000_4000 - 1000_4008 (mtimecmp)
///    1000_bff8 - 1000_c000 (mtime)
///
/// Main memory:
///    2000_0000 - 2000_0400
///
/// Only read/writes to the regions above are allowed. Any read or
/// write that falls partially or completely outside the ranges
/// will generate an access fault.
module data_mem(
	input clk, // clock (write on rising edge)
	input [31:0] write_addr, // write port address
	input [1:0] write_width, // write width
	input [31:0] write_data, // write port data
	input write_en, // 1 to write on rising clock edge, else 0 for no write
	input [31:0] read_addr, // read port address
	input [1:0] read_width, // read width
	output [31:0] read_data, // read port data output
	output load_access_fault, // set on LoadAccessFault exception
	output store_access_fault, // set on StoreAccessFault exception
	);
----

==== Notes

Maybe this is more like a physical memory attributes checker module, not the actual data memory. Ideally, the I/O region (with the memory-mapped CSRs and in the future, other peripherals) should be independent of the data memory. Probably a bus architecture of some kind is more appropriate, where the bus itself is the physical address space, but devices attached to the bus can opt to service the request if the address is within their memory range. There could be a data bus that contains the output, driven by whichever module is servicing the request. The physical memory attributes checker could also be attached to this bus.

Possible there is no need for a PMA checker at all -- if each peripheral connected to the bus "claims" the read or write by asserting a signal, then the PMA check could be as simple as checking that at least one device as claimed the read/write (a peripheral would only claim it if the entirety of the read/write falls within it's valid address range).

Any device on the data memory physical address bus could have the following signature:

[,verilog]
----
/// Example device connected to data memory bus
///
/// For this bus, only a single read or write is allowed at once. This
/// is fine, because only a load or store instruction is being executed
/// at once, and these are the only ways the CPU can access the data memory
/// (note that "back-channel" accesses, like updating memory mapped registers
/// like mtime internall, do not use the data memory bus for the access).
///
/// A device like this "claims" a read/write by asserting the "claim" signal,
/// depending on whether it "owns" the address range (determined from the
/// addr and width). By design, only a single device on the bus can claim
/// a read/write. Externally, all the claim signals are ORed together, and if
/// no device claims the read/write, an access fault occurs. (The write_en
/// signal is also shared between all devices, and this can be used in 
/// combination with the ORed claim signals to distinguish a load/store
/// access fault.)
///
/// If a write is claimed, the write is performed on the rising edge of the
/// clock. If a read is claimed, then the data_out line is set to the
/// result of the read. If the read is not claimed, the data_out line is
/// guaranteed to be zero. This means these lines can be ORed externally
/// to form the data_out bus.
module example_device(
	input clk, // if the device can be written to, it needs a clock
	input [31:0] addr, // the read/write address bus 
	input [1:0] width, /// the width of the read/write
	input [31:0] data_in, // data to be written on rising clock edge
	input write_en, // 1 to perform write, 0 otherwise
	output [31:0] data_out, // data out
	
	// other signals specific to the device
	);
----

Devices that are needed on the bus include:

* `main_memory`: fixed block of contiguous memory; claims reads/writes contained in the range `0x2000_0000 - 0x2000_0400`.
* `msip`: memory-mapped register, claims reads/writes in the range `0x1000_0000 - 0x1000_0004 `. Only the lowest bit is writable. Attempts to write other bits are ignored, and other bits always read as zero.
* `mtimecmp`: memory-mapped register, claims reads/writes in the range `0x1000_4000 - 0x1000_4008`.
* `mtime`: memory-mapped register, claims reads/writes in the range `0x1000_bff8 - 0x1000_c000`. Automatically increment on each clock cycle.



=== Control and Status Register Bus

The CSR registers are attached to an address space which is different from the data memory physical address space, but which can be implemented in the same way. Each CSR is represented as a device attached to the bus (similar CSRs can be grouped into a single module), with the following signature:

[,verilog]
----
module csr_module(
	input clk, // clock for writing on the rising edge
	input [11:0] addr, // CSR address. Used to claim a CSR read/write.
	input [31:0] write_data, // data to write to the CSR
	input write_en, // 1 to write on rising clock edge
	output read_data, //
	output claim, // 1 if this module owns the CSR addr
	output illegal_instr, // 1 if illegal instruction should be raised
	
	// Other arguments not related to CSR bus (e.g. memory mapping,
	// hardware access, etc.)
	);
----

Modules will be designed so that a given register is controlled by only a single module. These are the kinds of modules that will be present:

* read-only zero CSR modules: these only need a single CSR-bus port which always returns zero on reads or illegal instruction on writes. Examples include `mvendorid`, `marchid`, `mimpid`, `mhartid`, `mconfigptr`, `misa`, `mhpmcountern`, `mhpmcounternh`, `mhpmevent`, `hpmcountern`, `hpmcounternh`, `mtval` (these can all be collected into a single module)
* read/write CSRs which are not used by hardware: these require a read/write CSR-bus interface only. Examples are `mscratch`.
* read/write CSRs which can only be read by hardware: these need a read/write CSR-bus port, and access for hardware to read the bits. Examples include `mie`.
* read-only non-zero CSR modules: these return a non-zero value, but cause illegal instruction on writes. Examples include `mtvec`, 
* read/write CSRs which can also be written by hardware: these need a CSR-bus port for read/write, and also a direct-hardware port for the CPU to read/update the bits in the CSRs. Examples include `mstatus` and `mstatush` (note that this is a read/write register, even though all fields are read-only zero), `mcycle`, `mcycleh`, `minstret`, `minstreth`, `mcause`, `mepc`. These modules should also provide access to read-only shadows of these registers (like `cycle`, `cycleh`, `instret`, `instreth`).
* read-only memory-mapped CSRs updated by hardware: these require a CSR-bus supporting reads (writes return illegal instruction), and also a data memory bus for access via the physical address space. In addition, hardware requires a read/write port for reading and updating the values. Examples include `time` and `timeh` (i.e. 64-bit `mtime`)

==== Trap module (sequential)

This module is responsible for controlling interrupts and exceptions. It also holds the registers related to interrupts and exceptions, some of which are memory-mapped and some are exposed as CSRs. The signature of the module is shown below:

[,verilog]
----
/// Trap control (interrupts and exceptions)
///
/// This module holds the following status of the core:
///
/// mie: global interrupt enable bit in mstatus
/// mpie: previous mie in mstatus
/// msie, mtie, meie: software, timer and external 
/// interrupt enable bits in mie
/// msip, mtip, meip: software, timer and external
/// interrupt pending bits in mip
///
/// It holds the following memory-mapped registers
/// related to interrupt control:
///
/// mtime: 64-bit real-time register
/// mtimecmp: defines the trigger for a timer 
/// interrupt in relation to mtime
/// msip: register containing the software read/writable
/// msip bit
///
/// It manages/exposes the following control and status
/// registers:
///
/// mstatus: contains the mie, mpie and mpp bits
/// mepc: return address after trap
/// mcause: the cause of the trap
/// mtvec: defines the location and type of trap
/// handler vectors (this is hardcoded in this design)
///
/// In normal instruction execution, mtime is incremented
/// on the rising clock edge.
///
/// On Interrupts
/// ~~~~~~~~~~~~~
///
/// Interrupts are checked at the beginning of each 
/// execution cycle, "logically" before instruction
/// execution begins (therefore interrupts take priority
/// over exceptions). An interrupt trap occurs if:
///
/// 1) interrupts are globally enabled (mie set in mstatus)
/// AND
/// 2) external interrupt is enabled and pending (meie and meip)
/// OR software interrupt is enabled and pending (msie and msip)
/// OR timer interrupt is enabled and pending (mtie and mtip)
///
/// Interrupts in 2) are checked in the order given, and the
/// first enabled and pending interrupt is the one that traps.
///
/// The mcause register is set to (0x8000_0000 | code), where
/// code is 3 for software interrupt, 7 for timer interrupt,
/// or 11 for external interrupt. The interrupt_offset is set
/// to (code << 2). 
///
/// On Exceptions
/// ~~~~~~~~~~~~~
///
/// An exception is raised "mid" instruction (in the single-cycle
/// design, this means some combinational element will raise an
/// exception bit for the currently fetched instruction and core
/// state). All these bits are fed into an exception encoder,
/// which produces an exception bit and the mcause values.
/// These are used as input to this module.
///
/// As a result, an exception trap will occur. The mcause
/// register is set to the value of the mcause input. The
/// interrupt_offset is set to 0.
///
/// On Any Trap
/// ~~~~~~~~~~~~
/// 
/// On any trap (interrupts or exceptions), the mie bit is
/// copied to mpie in mstatus, and the mie bit is set to zero.
/// The exception_vector is set to the base address stored in
/// mtvec (this is hard-coded in this design). The current
/// program counter is copied to mepc
///
/// Any other instruction that may have executed on this clock
/// cycle must be disabled. This is achieved by disabling any
/// action that would change the core's state. This is the write
/// enable for the register file, the memory, and the CSR bus.
/// The design can use the trap ouptut to determine whether to
/// do this.
///
/// On Return From Trap
/// ~~~~~~~~~~~~~~~~~~~
///
/// If a return from trap is requested by setting the mret
/// input, then the mstatus mpie bit is copied to mie, and
/// the mpie bit is set to 1. (The mepc output is to be used by 
/// the next_pc_sel multiplexer to set the return address.)
///
module trap_ctrl(
       	input clk, // clock for updating registers
	
	input meip, // external interrupt source (from PLIC)
	input mret, // set to perform a return from trap
	input exception, // has an exception been raised
	input [31:0] mcause, // the cause of the exception
	input [31:0] pc, // used for setting mepc on exception
	
	output trap, // set if any trap is detected
	output interrupt, // set if an interrupt is detected
	output [31:0] mepc, // exception pc for use by next_pc_sel
	output [31:0] exception_vector, // for use by next_pc_set
	output [31:0] interrupt_offset, // for use by next_pc_set

	// Data memory read/write port
	input [31:0] data_mem_addr, // the read/write address bus 
	input [1:0] data_mem_width, /// the width of the read/write
	input [31:0] data_mem_wdata, // data to be written on rising clock edge
	input data_mem_write_en, // 1 to perform write, 0 otherwise
	output [31:0] data_mem_rdata, // data out	
	output data_mem_claim, // set if this module claims the data memory access
	
	// CSR bus read/write port
	input [11:0] csr_addr, // CSR address. Used to claim a CSR read/write.
	input [31:0] csr_wdata, // data to write to the CSR
	input csr_write_en, // 1 to write on rising clock edge
	output csr_rdata, // CSR read data
	output csr_claim, // 1 if this module owns the CSR addr
	output illegal_instr, // 1 if illegal instruction should be raised
	);
----

=== Exception encoder

This module is a combinational unit that takes all the possible exception flags (from the various other modules of the data path) and convert them into an exception bit and exception cause value for use as input into the trap module. The signature is as follows:

[,verilog]
----
/// Converts exception bits into mcause values
module exception_encoder(
	input instr_addr_mis, // instruction address misaligned, mcause 0
	input instr_access_fault, // instruction access fault, mcause 1
	input illegal_instr, // illegal instruction, mcause 2
	input breakpoint, // breakpoint (from ebreak), mcause 3
	// load address misaligned unused in this design
	input load_access_fault, // load access fault, mcause 5
	// store address misaligned unused in this design
	input store_access_fault, // store access fault, mcause 7
	input ecall_mmode, // ecall from M-mode, mcause 11
	output exception, // set on any exception
	output mcause, // what exception was raised
	);
----

=== Register file (sequential)

The register file has two combinational read ports and one sequential write port. The register file does not raise exceptions. The signature of the register file is shown below:

== Data path (multiplexers)

This section contains the designs for signal selection multiplexers at the inputs to most of the data path modules. They are named using the format `<module_name>_<input_name>_sel` where `<module_name>` and `<input_name>` specifies which signal of which module is being driven. The control signals for each multiplexer come from the control unit. Sometimes, the module may contain logic in addition to a multiplexer for generating the input signal.

Some signals do not require multiplexers, because they are always taken from the same source. The signals corresponding to register indices are as follows:

* `register_file_rs1` is always tied to the `rs1` field of the instructions (`instr[19:15]`)
* `register_file_rs2` is always tied to the `rs2` field of the instructions (`instr[24:20]`)
* `register_file_rd` is always tied to the `rd` field of the instructions (`instr[11:7]`)
* the CSR-bus address is always routed from the `csr` field in the CSR instruction format (`instr[31:20]`)
* the data memory bus address always comes from the main ALU output (only used in load/store instructions)
* the data memory bus write data always comes from the `rs2_data` read port of the register file.

It does not matter if these fields are not used in the instruction, and therefore contains junk; in these cases, `register_file_write_en` is de-asserted, and the combinational outputs `rs1_data` and `rs2_data` are ignored.

Only the load and store instructions can read or write to the data memory bus, which means the following signals are always routed:

* data memory bus `addr` always comes from the main ALU result `r`
* data memory bus `width` field is calculated statically from the instruction
* data memory bus `write_data` is routed from `rs2_data` from the register file

The multiplexers that select between different potential inputs are outlined below.

=== Main ALU input ports

There are two multiplexers which control the input ports to the main ALU: `main_alu_a_sel` and `main_alu_b_sel`. The following guidelines have been followed when selecting which signals is routed to which port of the main ALU:

* `rs1_data` and `rs2_data` are routed to ports `a` and `b` of the ALU
* immediate fields are typically routed to port `b` of the ALU
* the `pc` is routed to the first port of the ALU if it is needed
* for CSR instructions
** the CSR-bus data output is routed to port `b` of the main ALU
** port `a` is used for `rs1_data`, `!rs1_data`, and the `uimm`-derived immediates.

The signatures for the two ALU input multiplexers are as follows. The first port is controlled by:

[,verilog]
----
/// Selects the signal input for port a of the main ALU
///
/// The sel argument selects between the inputs (sel is in binary):
///  00: rs1_data, for register-register, register-immediate,
///  branch, load, store instructions
///  01: pc, for auipc and jal instructions
///  10: 0, for lui
///  11: csr_rdata, for CSR instructions 
///
module main_alu_a_sel(
	input [1:0] sel, // chooses the output signal
	input [31:0] rs1_data, // the value of rs1 from the register file
	input [31:0] pc, // for current program counter
	input [31:0] csr_rdata, // CSR-bus read data
	output a // the main ALU a signal
	);
----

The second port is controlled by:

[,verilog]
----
/// Selects the signal input for port b of the main ALU
///
/// The sel argument selects between the inputs (sel is in binary):
///  000: rs2_data, for register-register, branch instructions
///  001: imm, for register-immediate, load, store, jal, jalr, 
///  010: rs1_data, for csrrs
///  011: !rs1_data, for csrrc
///  100: { 27'b0, imm[4:0] }, for csrrsi
///  101: { 27'b0, !imm[4:0] }, for csrrci
///
/// The imm argument above needs generating according to whichever
/// instruction is being implemented; different instructions have
/// different formats for the immediate, and need it to be processsed
/// in different ways.
///
module main_alu_b_sel(
	input [2:0] sel, // chooses the output signal
	input [31:0] rs1_data, // the value of rs1 from the register file
	input [31:0] rs2_data, // the value of rs2 from the register file
	input [31:0] imm, // immediate field, already extracted/sign-extended
	output b // the main ALU b signal
	);
----

=== Register file write data

The `rd_data` signal for writing to `rd` is selected from multiple sources depending on the instruction. The module is given below


=== Trap controller CSR write data


=== Immediate generation for ALU operand `b`

Immediates are used in the following types of instructions: register-immediate, upper-immediate, load/store, jal.  The `uimm` field in CSR instructions is also excluded because that is routed to the main ALU operand `a`. The signature for the immediate generation is:

[,verilog]
----
/// Immediate generation for ALU operand b
///
/// Generate a 32-bit immediate for use in calculations
/// with the ALU. This includes register-immediates,
/// upper-immediates, loads, and stores, but does not
/// include any control flow instructions (which use
/// a dedicated ALU for adding to the program counter).
/// The sel input is used to pick the output immediate
/// as follows:
///
/// 000: { 20{instr[31]}, instr[31:20] }
/// for register-immediates, loads, stores, jalr
///
/// 001: { 27'b0, instr[24:20] }
/// for register-immediate shift instructions
///
/// 010: { instr[31:12], 12'b0 }
/// for upper-immediate instructions
///
/// 011: { 12{instr[31]}, instr[19:12], instr[20], instr[30:21], 1'b0 }
/// for jal instruction
///
/// 100: { 27'b0, instr[19:15] }
/// uimm, for CSR instructions
///
module main_alu_b_imm_sel(
       input [2:0] sel, // pick immediate calculation
       input [31:0] instr, // fetched instruction
       output [31:0] imm // output 32-bit immediate for calculation
       );
----

=== Immediate generation for branch offset

For conditional branch instructions, this module generates the `offset` field for inputting into the `pc` module:

[,verilog]
----
/// Extract and sign-extend the offset field from B-type
/// instructions:
///
/// offset = { 20{instr[12]}, instr[7], instr[30:25], instr[11:8], 1'b0 }
module branch_offset_imm_gen(
       input [31:0] instr,
       output [31:0] offset,
       );
----
////
